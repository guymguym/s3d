// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::AbortMultipartUploadInput>
    for Fun
where
    Fun: FnOnce(crate::input::AbortMultipartUploadInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::AbortMultipartUploadOutput,
                crate::error::AbortMultipartUploadError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::AbortMultipartUploadOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::AbortMultipartUploadOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::CompleteMultipartUploadInput,
    > for Fun
where
    Fun: FnOnce(crate::input::CompleteMultipartUploadInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::CompleteMultipartUploadOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CompleteMultipartUploadOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::CompleteMultipartUploadOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::CopyObjectInput> for Fun
where
    Fun: FnOnce(crate::input::CopyObjectInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::CopyObjectOutput, crate::error::CopyObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CopyObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::CopyObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::CreateBucketInput> for Fun
where
    Fun: FnOnce(crate::input::CreateBucketInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::CreateBucketOutput, crate::error::CreateBucketError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CreateBucketOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::CreateBucketOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::CreateMultipartUploadInput>
    for Fun
where
    Fun: FnOnce(crate::input::CreateMultipartUploadInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::CreateMultipartUploadOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CreateMultipartUploadOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::CreateMultipartUploadOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketInput> for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeleteBucketAnalyticsConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketAnalyticsConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketAnalyticsConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketAnalyticsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketAnalyticsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketCorsInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketCorsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketCorsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketCorsOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketCorsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketEncryptionInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketEncryptionInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketEncryptionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketEncryptionOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketEncryptionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeleteBucketIntelligentTieringConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketIntelligentTieringConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketIntelligentTieringConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketIntelligentTieringConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeleteBucketInventoryConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketInventoryConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketInventoryConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketInventoryConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketInventoryConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketLifecycleInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketLifecycleInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketLifecycleOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketLifecycleOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketLifecycleOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeleteBucketMetricsConfigurationInput,
    > for Fun
where
    Fun:
        FnOnce(crate::input::DeleteBucketMetricsConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketMetricsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketMetricsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketMetricsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeleteBucketOwnershipControlsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketOwnershipControlsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketOwnershipControlsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketOwnershipControlsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketOwnershipControlsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketPolicyInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketPolicyInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketPolicyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketPolicyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketPolicyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeleteBucketReplicationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketReplicationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketReplicationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketReplicationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketReplicationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketTaggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketTaggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteBucketWebsiteInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteBucketWebsiteInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketWebsiteOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketWebsiteOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteBucketWebsiteOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteObjectInput> for Fun
where
    Fun: FnOnce(crate::input::DeleteObjectInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteObjectOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteObjectOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteObjectsInput> for Fun
where
    Fun: FnOnce(crate::input::DeleteObjectsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteObjectsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteObjectsOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteObjectsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::DeleteObjectTaggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::DeleteObjectTaggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteObjectTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteObjectTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeleteObjectTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::DeletePublicAccessBlockInput,
    > for Fun
where
    Fun: FnOnce(crate::input::DeletePublicAccessBlockInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::DeletePublicAccessBlockOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeletePublicAccessBlockOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::DeletePublicAccessBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketAccelerateConfigurationInput,
    > for Fun
where
    Fun:
        FnOnce(crate::input::GetBucketAccelerateConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketAccelerateConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketAccelerateConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketAccelerateConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketAclInput> for Fun
where
    Fun: FnOnce(crate::input::GetBucketAclInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketAclOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketAnalyticsConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketAnalyticsConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketAnalyticsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketAnalyticsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketAnalyticsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketCorsInput> for Fun
where
    Fun: FnOnce(crate::input::GetBucketCorsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketCorsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketCorsOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketCorsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketEncryptionInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketEncryptionInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketEncryptionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketEncryptionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketEncryptionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketIntelligentTieringConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketIntelligentTieringConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketIntelligentTieringConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketIntelligentTieringConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketIntelligentTieringConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketInventoryConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketInventoryConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketInventoryConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketInventoryConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketInventoryConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketLifecycleConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketLifecycleConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketLifecycleConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketLifecycleConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketLifecycleConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketLocationInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketLocationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketLocationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketLocationOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketLocationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketLoggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketLoggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketLoggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketLoggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketLoggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketMetricsConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketMetricsConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketMetricsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketMetricsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketMetricsConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketNotificationConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketNotificationConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketNotificationConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketNotificationConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketNotificationConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketOwnershipControlsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketOwnershipControlsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketOwnershipControlsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketOwnershipControlsOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketOwnershipControlsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketPolicyInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketPolicyInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketPolicyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketPolicyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketPolicyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketPolicyStatusInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketPolicyStatusInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketPolicyStatusOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketPolicyStatusOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketPolicyStatusOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketReplicationInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketReplicationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketReplicationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketReplicationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketReplicationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetBucketRequestPaymentInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetBucketRequestPaymentInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketRequestPaymentOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketRequestPaymentOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketRequestPaymentOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketTaggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketTaggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketVersioningInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketVersioningInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketVersioningOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketVersioningOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketVersioningOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetBucketWebsiteInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetBucketWebsiteInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketWebsiteOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketWebsiteOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetBucketWebsiteOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetObjectInput> for Fun
where
    Fun: FnOnce(crate::input::GetObjectInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::GetObjectOutput, crate::error::GetObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetObjectAclInput> for Fun
where
    Fun: FnOnce(crate::input::GetObjectAclInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::GetObjectAclOutput, crate::error::GetObjectAclError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetObjectLegalHoldInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetObjectLegalHoldInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectLegalHoldOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectLegalHoldOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectLegalHoldOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::GetObjectLockConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::GetObjectLockConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectLockConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectLockConfigurationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectLockConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetObjectRetentionInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetObjectRetentionInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectRetentionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectRetentionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectRetentionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetObjectTaggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetObjectTaggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetObjectTorrentInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetObjectTorrentInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectTorrentOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectTorrentOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetObjectTorrentOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::GetPublicAccessBlockInput>
    for Fun
where
    Fun: FnOnce(crate::input::GetPublicAccessBlockInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::GetPublicAccessBlockOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetPublicAccessBlockOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetPublicAccessBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::HeadBucketInput> for Fun
where
    Fun: FnOnce(crate::input::HeadBucketInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::HeadBucketOutput, crate::error::HeadBucketError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::HeadBucketOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::HeadBucketOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::HeadObjectInput> for Fun
where
    Fun: FnOnce(crate::input::HeadObjectInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::HeadObjectOutput, crate::error::HeadObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::HeadObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::HeadObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::ListBucketAnalyticsConfigurationsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::ListBucketAnalyticsConfigurationsInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut:
        std::future::Future<Output = crate::output::ListBucketAnalyticsConfigurationsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketAnalyticsConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListBucketAnalyticsConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::ListBucketIntelligentTieringConfigurationsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::ListBucketIntelligentTieringConfigurationsInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = crate::output::ListBucketIntelligentTieringConfigurationsOutput,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketIntelligentTieringConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListBucketIntelligentTieringConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::ListBucketInventoryConfigurationsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::ListBucketInventoryConfigurationsInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut:
        std::future::Future<Output = crate::output::ListBucketInventoryConfigurationsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketInventoryConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListBucketInventoryConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::ListBucketMetricsConfigurationsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::ListBucketMetricsConfigurationsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::ListBucketMetricsConfigurationsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketMetricsConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListBucketMetricsConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::ListBucketsInput> for Fun
where
    Fun: FnOnce(crate::input::ListBucketsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::ListBucketsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketsOperationInputWrapper::from_request(
            &mut req,
        )
        .await
        {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListBucketsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::ListMultipartUploadsInput>
    for Fun
where
    Fun: FnOnce(crate::input::ListMultipartUploadsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::ListMultipartUploadsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListMultipartUploadsOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListMultipartUploadsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::ListObjectsInput> for Fun
where
    Fun: FnOnce(crate::input::ListObjectsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::ListObjectsOutput, crate::error::ListObjectsError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListObjectsOperationInputWrapper::from_request(
            &mut req,
        )
        .await
        {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListObjectsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::ListObjectsV2Input> for Fun
where
    Fun: FnOnce(crate::input::ListObjectsV2Input) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::ListObjectsV2Output, crate::error::ListObjectsV2Error>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListObjectsV2OperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListObjectsV2OperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::ListObjectVersionsInput>
    for Fun
where
    Fun: FnOnce(crate::input::ListObjectVersionsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::ListObjectVersionsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListObjectVersionsOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListObjectVersionsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::ListPartsInput> for Fun
where
    Fun: FnOnce(crate::input::ListPartsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::ListPartsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListPartsOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListPartsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketAccelerateConfigurationInput,
    > for Fun
where
    Fun:
        FnOnce(crate::input::PutBucketAccelerateConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketAccelerateConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketAccelerateConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketAccelerateConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketAclInput> for Fun
where
    Fun: FnOnce(crate::input::PutBucketAclInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketAclOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketAnalyticsConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketAnalyticsConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketAnalyticsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketAnalyticsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketAnalyticsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketCorsInput> for Fun
where
    Fun: FnOnce(crate::input::PutBucketCorsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketCorsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketCorsOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketCorsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketEncryptionInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketEncryptionInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketEncryptionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketEncryptionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketEncryptionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketIntelligentTieringConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketIntelligentTieringConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketIntelligentTieringConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketIntelligentTieringConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketIntelligentTieringConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketInventoryConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketInventoryConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketInventoryConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketInventoryConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketInventoryConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketLifecycleConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketLifecycleConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketLifecycleConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketLifecycleConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketLifecycleConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketLoggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketLoggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketLoggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketLoggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketLoggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketMetricsConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketMetricsConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketMetricsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketMetricsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketMetricsConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketNotificationConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketNotificationConfigurationInput) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketNotificationConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketNotificationConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketNotificationConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketOwnershipControlsInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketOwnershipControlsInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketOwnershipControlsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketOwnershipControlsOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketOwnershipControlsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketPolicyInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketPolicyInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketPolicyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketPolicyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketPolicyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketReplicationInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketReplicationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketReplicationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketReplicationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketReplicationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutBucketRequestPaymentInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutBucketRequestPaymentInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketRequestPaymentOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketRequestPaymentOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketRequestPaymentOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketTaggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketTaggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketVersioningInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketVersioningInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketVersioningOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketVersioningOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketVersioningOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutBucketWebsiteInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutBucketWebsiteInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketWebsiteOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketWebsiteOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutBucketWebsiteOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutObjectInput> for Fun
where
    Fun: FnOnce(crate::input::PutObjectInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutObjectOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutObjectAclInput> for Fun
where
    Fun: FnOnce(crate::input::PutObjectAclInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::PutObjectAclOutput, crate::error::PutObjectAclError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutObjectAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutObjectLegalHoldInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutObjectLegalHoldInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectLegalHoldOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectLegalHoldOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutObjectLegalHoldOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<
        B,
        (),
        crate::input::PutObjectLockConfigurationInput,
    > for Fun
where
    Fun: FnOnce(crate::input::PutObjectLockConfigurationInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectLockConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectLockConfigurationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutObjectLockConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutObjectRetentionInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutObjectRetentionInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectRetentionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectRetentionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutObjectRetentionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutObjectTaggingInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutObjectTaggingInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutObjectTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::PutPublicAccessBlockInput>
    for Fun
where
    Fun: FnOnce(crate::input::PutPublicAccessBlockInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::PutPublicAccessBlockOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutPublicAccessBlockOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutPublicAccessBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::RestoreObjectInput> for Fun
where
    Fun: FnOnce(crate::input::RestoreObjectInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::RestoreObjectOutput, crate::error::RestoreObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::RestoreObjectOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::RestoreObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::UploadPartInput> for Fun
where
    Fun: FnOnce(crate::input::UploadPartInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::UploadPartOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::UploadPartOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::UploadPartOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::UploadPartCopyInput> for Fun
where
    Fun: FnOnce(crate::input::UploadPartCopyInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::UploadPartCopyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::UploadPartCopyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::UploadPartCopyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut>
    crate::server_operation_handler_trait::Handler<B, (), crate::input::WriteGetObjectResponseInput>
    for Fun
where
    Fun: FnOnce(crate::input::WriteGetObjectResponseInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<Output = crate::output::WriteGetObjectResponseOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::WriteGetObjectResponseOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::WriteGetObjectResponseOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::AbortMultipartUploadInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::AbortMultipartUploadInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::AbortMultipartUploadOutput,
                crate::error::AbortMultipartUploadError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::AbortMultipartUploadOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::AbortMultipartUploadOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::CompleteMultipartUploadInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::CompleteMultipartUploadInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::CompleteMultipartUploadOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CompleteMultipartUploadOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::CompleteMultipartUploadOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::CopyObjectInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::CopyObjectInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::CopyObjectOutput, crate::error::CopyObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CopyObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::CopyObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::CreateBucketInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::CreateBucketInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::CreateBucketOutput, crate::error::CreateBucketError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CreateBucketOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::CreateBucketOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::CreateMultipartUploadInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::CreateMultipartUploadInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::CreateMultipartUploadOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CreateMultipartUploadOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::CreateMultipartUploadOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteBucketInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketAnalyticsConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketAnalyticsConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketAnalyticsConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketAnalyticsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketAnalyticsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketCorsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteBucketCorsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketCorsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketCorsOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketCorsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketEncryptionInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketEncryptionInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketEncryptionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketEncryptionOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketEncryptionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketIntelligentTieringConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketIntelligentTieringConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketIntelligentTieringConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketIntelligentTieringConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketInventoryConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketInventoryConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketInventoryConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketInventoryConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketInventoryConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketLifecycleInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketLifecycleInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketLifecycleOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketLifecycleOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketLifecycleOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketMetricsConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketMetricsConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketMetricsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketMetricsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketMetricsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketOwnershipControlsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketOwnershipControlsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketOwnershipControlsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::DeleteBucketOwnershipControlsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketOwnershipControlsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketPolicyInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteBucketPolicyInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketPolicyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketPolicyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketPolicyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketReplicationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeleteBucketReplicationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketReplicationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketReplicationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketReplicationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketTaggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteBucketTaggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteBucketWebsiteInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteBucketWebsiteInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteBucketWebsiteOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteBucketWebsiteOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteBucketWebsiteOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteObjectInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteObjectInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteObjectOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteObjectOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteObjectsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteObjectsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteObjectsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteObjectsOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteObjectsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeleteObjectTaggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::DeleteObjectTaggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeleteObjectTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeleteObjectTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeleteObjectTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::DeletePublicAccessBlockInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::DeletePublicAccessBlockInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::DeletePublicAccessBlockOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::DeletePublicAccessBlockOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::DeletePublicAccessBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketAccelerateConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketAccelerateConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketAccelerateConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketAccelerateConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketAccelerateConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketAclInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketAclInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketAclOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketAnalyticsConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketAnalyticsConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketAnalyticsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketAnalyticsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketAnalyticsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketCorsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketCorsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketCorsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketCorsOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketCorsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketEncryptionInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketEncryptionInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketEncryptionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketEncryptionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketEncryptionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketIntelligentTieringConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketIntelligentTieringConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketIntelligentTieringConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketIntelligentTieringConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketIntelligentTieringConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketInventoryConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketInventoryConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketInventoryConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketInventoryConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketInventoryConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketLifecycleConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketLifecycleConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketLifecycleConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketLifecycleConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketLifecycleConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketLocationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketLocationInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketLocationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketLocationOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketLocationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketLoggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketLoggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketLoggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketLoggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketLoggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketMetricsConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketMetricsConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketMetricsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketMetricsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketMetricsConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketNotificationConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketNotificationConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketNotificationConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::GetBucketNotificationConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketNotificationConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketOwnershipControlsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketOwnershipControlsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketOwnershipControlsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketOwnershipControlsOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketOwnershipControlsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketPolicyInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketPolicyInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketPolicyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketPolicyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketPolicyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketPolicyStatusInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketPolicyStatusInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketPolicyStatusOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketPolicyStatusOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketPolicyStatusOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketReplicationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketReplicationInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketReplicationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketReplicationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketReplicationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketRequestPaymentInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetBucketRequestPaymentInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketRequestPaymentOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketRequestPaymentOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketRequestPaymentOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketTaggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketTaggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketVersioningInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketVersioningInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketVersioningOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketVersioningOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketVersioningOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetBucketWebsiteInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetBucketWebsiteInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetBucketWebsiteOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetBucketWebsiteOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetBucketWebsiteOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetObjectInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::GetObjectOutput, crate::error::GetObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectAclInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetObjectAclInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::GetObjectAclOutput, crate::error::GetObjectAclError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectLegalHoldInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetObjectLegalHoldInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectLegalHoldOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectLegalHoldOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectLegalHoldOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectLockConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::GetObjectLockConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectLockConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectLockConfigurationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectLockConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectRetentionInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetObjectRetentionInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectRetentionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectRetentionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectRetentionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectTaggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetObjectTaggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetObjectTorrentInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetObjectTorrentInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetObjectTorrentOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetObjectTorrentOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetObjectTorrentOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::GetPublicAccessBlockInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetPublicAccessBlockInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::GetPublicAccessBlockOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetPublicAccessBlockOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetPublicAccessBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::HeadBucketInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::HeadBucketInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::HeadBucketOutput, crate::error::HeadBucketError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::HeadBucketOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::HeadBucketOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::HeadObjectInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::HeadObjectInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::HeadObjectOutput, crate::error::HeadObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::HeadObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::HeadObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListBucketAnalyticsConfigurationsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::ListBucketAnalyticsConfigurationsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut:
        std::future::Future<Output = crate::output::ListBucketAnalyticsConfigurationsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketAnalyticsConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListBucketAnalyticsConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListBucketIntelligentTieringConfigurationsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::ListBucketIntelligentTieringConfigurationsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = crate::output::ListBucketIntelligentTieringConfigurationsOutput,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketIntelligentTieringConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListBucketIntelligentTieringConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListBucketInventoryConfigurationsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::ListBucketInventoryConfigurationsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut:
        std::future::Future<Output = crate::output::ListBucketInventoryConfigurationsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketInventoryConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListBucketInventoryConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListBucketMetricsConfigurationsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::ListBucketMetricsConfigurationsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::ListBucketMetricsConfigurationsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketMetricsConfigurationsOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListBucketMetricsConfigurationsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListBucketsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListBucketsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::ListBucketsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListBucketsOperationInputWrapper::from_request(
            &mut req,
        )
        .await
        {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListBucketsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListMultipartUploadsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListMultipartUploadsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::ListMultipartUploadsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListMultipartUploadsOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListMultipartUploadsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListObjectsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListObjectsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::ListObjectsOutput, crate::error::ListObjectsError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::ListObjectsOperationInputWrapper::from_request(
            &mut req,
        )
        .await
        {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListObjectsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListObjectsV2Input,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListObjectsV2Input, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::ListObjectsV2Output, crate::error::ListObjectsV2Error>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListObjectsV2OperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListObjectsV2OperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListObjectVersionsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListObjectVersionsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::ListObjectVersionsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListObjectVersionsOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListObjectVersionsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::ListPartsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListPartsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::ListPartsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListPartsOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListPartsOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketAccelerateConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketAccelerateConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketAccelerateConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketAccelerateConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketAccelerateConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketAclInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketAclInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketAclOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketAnalyticsConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketAnalyticsConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketAnalyticsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketAnalyticsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketAnalyticsConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketCorsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketCorsInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketCorsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketCorsOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketCorsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketEncryptionInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketEncryptionInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketEncryptionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketEncryptionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketEncryptionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketIntelligentTieringConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketIntelligentTieringConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketIntelligentTieringConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketIntelligentTieringConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketIntelligentTieringConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketInventoryConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketInventoryConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketInventoryConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketInventoryConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketInventoryConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketLifecycleConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketLifecycleConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketLifecycleConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketLifecycleConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketLifecycleConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketLoggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketLoggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketLoggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketLoggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketLoggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketMetricsConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketMetricsConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketMetricsConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketMetricsConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketMetricsConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketNotificationConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketNotificationConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketNotificationConfigurationOutput>
        + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper = match crate::operation::PutBucketNotificationConfigurationOperationInputWrapper::from_request(&mut req).await {
                                Ok(v) => v,
                                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                    }
                            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketNotificationConfigurationOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketOwnershipControlsInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketOwnershipControlsInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketOwnershipControlsOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketOwnershipControlsOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketOwnershipControlsOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketPolicyInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketPolicyInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketPolicyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketPolicyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketPolicyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketReplicationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketReplicationInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketReplicationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketReplicationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketReplicationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketRequestPaymentInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutBucketRequestPaymentInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketRequestPaymentOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketRequestPaymentOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketRequestPaymentOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketTaggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketTaggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketVersioningInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketVersioningInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketVersioningOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketVersioningOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketVersioningOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutBucketWebsiteInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutBucketWebsiteInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutBucketWebsiteOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutBucketWebsiteOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutBucketWebsiteOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutObjectInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutObjectInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutObjectOperationOutputWrapper = output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutObjectAclInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutObjectAclInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::PutObjectAclOutput, crate::error::PutObjectAclError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectAclOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutObjectAclOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutObjectLegalHoldInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutObjectLegalHoldInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectLegalHoldOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectLegalHoldOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutObjectLegalHoldOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutObjectLockConfigurationInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::PutObjectLockConfigurationInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectLockConfigurationOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectLockConfigurationOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutObjectLockConfigurationOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutObjectRetentionInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutObjectRetentionInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectRetentionOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectRetentionOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutObjectRetentionOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutObjectTaggingInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutObjectTaggingInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutObjectTaggingOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutObjectTaggingOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutObjectTaggingOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::PutPublicAccessBlockInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutPublicAccessBlockInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::PutPublicAccessBlockOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutPublicAccessBlockOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutPublicAccessBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::RestoreObjectInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::RestoreObjectInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::RestoreObjectOutput, crate::error::RestoreObjectError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::RestoreObjectOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::RestoreObjectOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::UploadPartInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::UploadPartInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::UploadPartOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::UploadPartOperationInputWrapper::from_request(&mut req).await {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::UploadPartOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::UploadPartCopyInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::UploadPartCopyInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::UploadPartCopyOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::UploadPartCopyOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::UploadPartCopyOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
#[async_trait::async_trait]
impl<B, Fun, Fut, S>
    crate::server_operation_handler_trait::Handler<
        B,
        aws_smithy_http_server::Extension<S>,
        crate::input::WriteGetObjectResponseInput,
    > for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(
            crate::input::WriteGetObjectResponseInput,
            aws_smithy_http_server::Extension<S>,
        ) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<Output = crate::output::WriteGetObjectResponseOutput> + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = crate::server_operation_handler_trait::sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum_core::extract::RequestParts::new(req);
        use axum_core::extract::FromRequest;
        use axum_core::response::IntoResponse;
        let input_wrapper =
            match crate::operation::WriteGetObjectResponseOperationInputWrapper::from_request(
                &mut req,
            )
            .await
            {
                Ok(v) => v,
                Err(r) => {
                    let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                    let mut response = r.into_response();
                    response.extensions_mut().insert(error);
                    return response.map(aws_smithy_http_server::boxed);
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                let error = aws_smithy_http_server::ExtensionRejection::new(r.to_string());
                let mut response = r.into_response();
                response.extensions_mut().insert(error);
                return response.map(aws_smithy_http_server::boxed);
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::WriteGetObjectResponseOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::boxed)
    }
}
