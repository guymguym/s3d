// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn serialize_abort_multipart_upload_response(
    output: crate::output::AbortMultipartUploadOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_1) = &output.request_charged {
            let formatted_2 = AsRef::<str>::as_ref(inner_1);
            if !formatted_2.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_2;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_abort_multipart_upload(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_abort_multipart_upload_error(
    error: &crate::error::AbortMultipartUploadError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::AbortMultipartUploadError::NoSuchUpload(var_3) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_no_such_upload(var_3)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_complete_multipart_upload_response(
    output: crate::output::CompleteMultipartUploadOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_4 = encoder.encode();
            if !formatted_4.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_4;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_5) = &output.expiration {
            let formatted_6 = AsRef::<str>::as_ref(inner_5);
            if !formatted_6.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_6;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expiration", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-expiration", header_value);
            }
        }
        if let Some(inner_7) = &output.request_charged {
            let formatted_8 = AsRef::<str>::as_ref(inner_7);
            if !formatted_8.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_8;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_9) = &output.ssekms_key_id {
            let formatted_10 = AsRef::<str>::as_ref(inner_9);
            if !formatted_10.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_10;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_11) = &output.server_side_encryption {
            let formatted_12 = AsRef::<str>::as_ref(inner_11);
            if !formatted_12.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_12;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_13) = &output.version_id {
            let formatted_14 = AsRef::<str>::as_ref(inner_13);
            if !formatted_14.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_14;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_complete_multipart_upload(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_copy_object_response(
    output: crate::output::CopyObjectOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_15 = encoder.encode();
            if !formatted_15.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_15;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_16) = &output.copy_source_version_id {
            let formatted_17 = AsRef::<str>::as_ref(inner_16);
            if !formatted_17.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_17;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "copy_source_version_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-copy-source-version-id", header_value);
            }
        }
        if let Some(inner_18) = &output.expiration {
            let formatted_19 = AsRef::<str>::as_ref(inner_18);
            if !formatted_19.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_19;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expiration", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-expiration", header_value);
            }
        }
        if let Some(inner_20) = &output.request_charged {
            let formatted_21 = AsRef::<str>::as_ref(inner_20);
            if !formatted_21.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_21;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_22) = &output.sse_customer_algorithm {
            let formatted_23 = AsRef::<str>::as_ref(inner_22);
            if !formatted_23.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_23;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_24) = &output.sse_customer_key_md5 {
            let formatted_25 = AsRef::<str>::as_ref(inner_24);
            if !formatted_25.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_25;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_26) = &output.ssekms_encryption_context {
            let formatted_27 = AsRef::<str>::as_ref(inner_26);
            if !formatted_27.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_27;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_encryption_context", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption-context", header_value);
            }
        }
        if let Some(inner_28) = &output.ssekms_key_id {
            let formatted_29 = AsRef::<str>::as_ref(inner_28);
            if !formatted_29.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_29;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_30) = &output.server_side_encryption {
            let formatted_31 = AsRef::<str>::as_ref(inner_30);
            if !formatted_31.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_31;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_32) = &output.version_id {
            let formatted_33 = AsRef::<str>::as_ref(inner_32);
            if !formatted_33.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_33;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_copy_object(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_copy_object_error(
    error: &crate::error::CopyObjectError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::CopyObjectError::ObjectNotInActiveTierError(var_34) => {
                let payload = crate::operation_ser::serialize_structure_crate_error_object_not_in_active_tier_error(var_34)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_create_bucket_response(
    output: crate::output::CreateBucketOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_35) = &output.location {
            let formatted_36 = AsRef::<str>::as_ref(inner_35);
            if !formatted_36.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_36;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "location", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("Location", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_create_bucket(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_create_bucket_error(
    error: &crate::error::CreateBucketError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::CreateBucketError::BucketAlreadyOwnedByYou(var_37) => {
                let payload = crate::operation_ser::serialize_structure_crate_error_bucket_already_owned_by_you(var_37)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
            crate::error::CreateBucketError::BucketAlreadyExists(var_38) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_bucket_already_exists(
                        var_38,
                    )?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_create_multipart_upload_response(
    output: crate::output::CreateMultipartUploadOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_39) = &output.abort_date {
            let formatted_40 = inner_39.fmt(aws_smithy_types::date_time::Format::HttpDate)?;
            if !formatted_40.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_40;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "abort_date", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-abort-date", header_value);
            }
        }
        if let Some(inner_41) = &output.abort_rule_id {
            let formatted_42 = AsRef::<str>::as_ref(inner_41);
            if !formatted_42.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_42;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "abort_rule_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-abort-rule-id", header_value);
            }
        }
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_43 = encoder.encode();
            if !formatted_43.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_43;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_44) = &output.request_charged {
            let formatted_45 = AsRef::<str>::as_ref(inner_44);
            if !formatted_45.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_45;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_46) = &output.sse_customer_algorithm {
            let formatted_47 = AsRef::<str>::as_ref(inner_46);
            if !formatted_47.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_47;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_48) = &output.sse_customer_key_md5 {
            let formatted_49 = AsRef::<str>::as_ref(inner_48);
            if !formatted_49.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_49;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_50) = &output.ssekms_encryption_context {
            let formatted_51 = AsRef::<str>::as_ref(inner_50);
            if !formatted_51.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_51;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_encryption_context", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption-context", header_value);
            }
        }
        if let Some(inner_52) = &output.ssekms_key_id {
            let formatted_53 = AsRef::<str>::as_ref(inner_52);
            if !formatted_53.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_53;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_54) = &output.server_side_encryption {
            let formatted_55 = AsRef::<str>::as_ref(inner_54);
            if !formatted_55.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_55;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_create_multipart_upload(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_response(
    output: crate::output::DeleteBucketOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_analytics_configuration_response(
    output: crate::output::DeleteBucketAnalyticsConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_delete_bucket_analytics_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_cors_response(
    output: crate::output::DeleteBucketCorsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_cors(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_encryption_response(
    output: crate::output::DeleteBucketEncryptionOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_encryption(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_intelligent_tiering_configuration_response(
    output: crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_delete_bucket_intelligent_tiering_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_inventory_configuration_response(
    output: crate::output::DeleteBucketInventoryConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_delete_bucket_inventory_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_lifecycle_response(
    output: crate::output::DeleteBucketLifecycleOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_lifecycle(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_metrics_configuration_response(
    output: crate::output::DeleteBucketMetricsConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_delete_bucket_metrics_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_ownership_controls_response(
    output: crate::output::DeleteBucketOwnershipControlsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_delete_bucket_ownership_controls(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_policy_response(
    output: crate::output::DeleteBucketPolicyOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_policy(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_replication_response(
    output: crate::output::DeleteBucketReplicationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_replication(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_tagging_response(
    output: crate::output::DeleteBucketTaggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_tagging(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_bucket_website_response(
    output: crate::output::DeleteBucketWebsiteOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_website(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_object_response(
    output: crate::output::DeleteObjectOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if output.delete_marker {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.delete_marker);
            let formatted_56 = encoder.encode();
            if !formatted_56.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_56;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "delete_marker", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-delete-marker", header_value);
            }
        }
        if let Some(inner_57) = &output.request_charged {
            let formatted_58 = AsRef::<str>::as_ref(inner_57);
            if !formatted_58.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_58;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_59) = &output.version_id {
            let formatted_60 = AsRef::<str>::as_ref(inner_59);
            if !formatted_60.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_60;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_object(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_objects_response(
    output: crate::output::DeleteObjectsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_61) = &output.request_charged {
            let formatted_62 = AsRef::<str>::as_ref(inner_61);
            if !formatted_62.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_62;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_objects(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_object_tagging_response(
    output: crate::output::DeleteObjectTaggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_63) = &output.version_id {
            let formatted_64 = AsRef::<str>::as_ref(inner_63);
            if !formatted_64.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_64;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_object_tagging(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_delete_public_access_block_response(
    output: crate::output::DeletePublicAccessBlockOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_delete_public_access_block(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_accelerate_configuration_response(
    output: crate::output::GetBucketAccelerateConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_accelerate_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_acl_response(
    output: crate::output::GetBucketAclOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_acl(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_analytics_configuration_response(
    output: crate::output::GetBucketAnalyticsConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_analytics_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_cors_response(
    output: crate::output::GetBucketCorsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_cors(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_encryption_response(
    output: crate::output::GetBucketEncryptionOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_encryption(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_intelligent_tiering_configuration_response(
    output: crate::output::GetBucketIntelligentTieringConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_intelligent_tiering_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_inventory_configuration_response(
    output: crate::output::GetBucketInventoryConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_inventory_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_lifecycle_configuration_response(
    output: crate::output::GetBucketLifecycleConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_lifecycle_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_location_response(
    output: crate::output::GetBucketLocationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_location(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_logging_response(
    output: crate::output::GetBucketLoggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_logging(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_metrics_configuration_response(
    output: crate::output::GetBucketMetricsConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_metrics_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_notification_configuration_response(
    output: crate::output::GetBucketNotificationConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_notification_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_ownership_controls_response(
    output: crate::output::GetBucketOwnershipControlsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_bucket_ownership_controls(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_policy_response(
    output: crate::output::GetBucketPolicyOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_policy(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_policy_status_response(
    output: crate::output::GetBucketPolicyStatusOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_policy_status(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_replication_response(
    output: crate::output::GetBucketReplicationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_replication(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_request_payment_response(
    output: crate::output::GetBucketRequestPaymentOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_request_payment(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_tagging_response(
    output: crate::output::GetBucketTaggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_tagging(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_versioning_response(
    output: crate::output::GetBucketVersioningOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_versioning(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_bucket_website_response(
    output: crate::output::GetBucketWebsiteOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_website(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_response(
    output: crate::output::GetObjectOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_65) = &output.accept_ranges {
            let formatted_66 = AsRef::<str>::as_ref(inner_65);
            if !formatted_66.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_66;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "accept_ranges", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("accept-ranges", header_value);
            }
        }
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_67 = encoder.encode();
            if !formatted_67.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_67;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_68) = &output.cache_control {
            let formatted_69 = AsRef::<str>::as_ref(inner_68);
            if !formatted_69.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_69;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "cache_control", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Cache-Control", header_value);
            }
        }
        if let Some(inner_70) = &output.content_disposition {
            let formatted_71 = AsRef::<str>::as_ref(inner_70);
            if !formatted_71.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_71;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_disposition", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Disposition", header_value);
            }
        }
        if let Some(inner_72) = &output.content_encoding {
            let formatted_73 = AsRef::<str>::as_ref(inner_72);
            if !formatted_73.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_73;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_encoding", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Encoding", header_value);
            }
        }
        if let Some(inner_74) = &output.content_language {
            let formatted_75 = AsRef::<str>::as_ref(inner_74);
            if !formatted_75.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_75;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_language", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Language", header_value);
            }
        }
        if output.content_length != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.content_length);
            let formatted_76 = encoder.encode();
            if !formatted_76.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_76;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_length", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Length", header_value);
            }
        }
        if let Some(inner_77) = &output.content_range {
            let formatted_78 = AsRef::<str>::as_ref(inner_77);
            if !formatted_78.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_78;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_range", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Range", header_value);
            }
        }
        if let Some(inner_79) = &output.content_type {
            let formatted_80 = AsRef::<str>::as_ref(inner_79);
            if !formatted_80.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_80;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_type", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Type", header_value);
            }
        }
        if output.delete_marker {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.delete_marker);
            let formatted_81 = encoder.encode();
            if !formatted_81.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_81;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "delete_marker", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-delete-marker", header_value);
            }
        }
        if let Some(inner_82) = &output.e_tag {
            let formatted_83 = AsRef::<str>::as_ref(inner_82);
            if !formatted_83.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_83;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "e_tag", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("ETag", header_value);
            }
        }
        if let Some(inner_84) = &output.expiration {
            let formatted_85 = AsRef::<str>::as_ref(inner_84);
            if !formatted_85.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_85;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expiration", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-expiration", header_value);
            }
        }
        if let Some(inner_86) = &output.expires {
            let formatted_87 = inner_86.fmt(aws_smithy_types::date_time::Format::HttpDate)?;
            if !formatted_87.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_87;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expires", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("Expires", header_value);
            }
        }
        if let Some(inner_88) = &output.last_modified {
            let formatted_89 = inner_88.fmt(aws_smithy_types::date_time::Format::HttpDate)?;
            if !formatted_89.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_89;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "last_modified", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Last-Modified", header_value);
            }
        }
        if let Some(inner_90) = &output.metadata {
            for (k, v) in inner_90 {
                use std::str::FromStr;
                let header_name =
                    http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                        .map_err(|err| {
                            aws_smithy_http_server::rejection::Serialize::from(
                                format!("{} cannot be used as a header name: {}", "metadata", err)
                                    .as_str(),
                            )
                        })?;
                use std::convert::TryFrom;
                let header_value = AsRef::<str>::as_ref(v);
                let header_value =
                    http::header::HeaderValue::try_from(header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "metadata", err)
                                .as_str(),
                        )
                    })?;
                response = response.header(header_name, header_value);
            }
        }
        if output.missing_meta != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.missing_meta);
            let formatted_91 = encoder.encode();
            if !formatted_91.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_91;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "missing_meta", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-missing-meta", header_value);
            }
        }
        if let Some(inner_92) = &output.object_lock_legal_hold_status {
            let formatted_93 = AsRef::<str>::as_ref(inner_92);
            if !formatted_93.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_93;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "object_lock_legal_hold_status", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-object-lock-legal-hold", header_value);
            }
        }
        if let Some(inner_94) = &output.object_lock_mode {
            let formatted_95 = AsRef::<str>::as_ref(inner_94);
            if !formatted_95.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_95;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "object_lock_mode", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-object-lock-mode", header_value);
            }
        }
        if let Some(inner_96) = &output.object_lock_retain_until_date {
            let formatted_97 = inner_96.fmt(aws_smithy_types::date_time::Format::DateTime)?;
            if !formatted_97.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_97;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "object_lock_retain_until_date", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-object-lock-retain-until-date", header_value);
            }
        }
        if output.parts_count != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.parts_count);
            let formatted_98 = encoder.encode();
            if !formatted_98.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_98;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "parts_count", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-mp-parts-count", header_value);
            }
        }
        if let Some(inner_99) = &output.replication_status {
            let formatted_100 = AsRef::<str>::as_ref(inner_99);
            if !formatted_100.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_100;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "replication_status", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-replication-status", header_value);
            }
        }
        if let Some(inner_101) = &output.request_charged {
            let formatted_102 = AsRef::<str>::as_ref(inner_101);
            if !formatted_102.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_102;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_103) = &output.restore {
            let formatted_104 = AsRef::<str>::as_ref(inner_103);
            if !formatted_104.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_104;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "restore", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-restore", header_value);
            }
        }
        if let Some(inner_105) = &output.sse_customer_algorithm {
            let formatted_106 = AsRef::<str>::as_ref(inner_105);
            if !formatted_106.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_106;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_107) = &output.sse_customer_key_md5 {
            let formatted_108 = AsRef::<str>::as_ref(inner_107);
            if !formatted_108.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_108;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_109) = &output.ssekms_key_id {
            let formatted_110 = AsRef::<str>::as_ref(inner_109);
            if !formatted_110.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_110;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_111) = &output.server_side_encryption {
            let formatted_112 = AsRef::<str>::as_ref(inner_111);
            if !formatted_112.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_112;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_113) = &output.storage_class {
            let formatted_114 = AsRef::<str>::as_ref(inner_113);
            if !formatted_114.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_114;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "storage_class", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-storage-class", header_value);
            }
        }
        if output.tag_count != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.tag_count);
            let formatted_115 = encoder.encode();
            if !formatted_115.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_115;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "tag_count", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-tagging-count", header_value);
            }
        }
        if let Some(inner_116) = &output.version_id {
            let formatted_117 = AsRef::<str>::as_ref(inner_116);
            if !formatted_117.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_117;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        if let Some(inner_118) = &output.website_redirect_location {
            let formatted_119 = AsRef::<str>::as_ref(inner_118);
            if !formatted_119.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_119;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "website_redirect_location", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-website-redirect-location", header_value);
            }
        }
        let payload = aws_smithy_http_server::body::Body::wrap_stream(output.body);
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_error(
    error: &crate::error::GetObjectError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::GetObjectError::NoSuchKey(var_120) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_no_such_key(var_120)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
            crate::error::GetObjectError::InvalidObjectState(var_121) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_invalid_object_state(
                        var_121,
                    )?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_acl_response(
    output: crate::output::GetObjectAclOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_122) = &output.request_charged {
            let formatted_123 = AsRef::<str>::as_ref(inner_122);
            if !formatted_123.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_123;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_object_acl(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_acl_error(
    error: &crate::error::GetObjectAclError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::GetObjectAclError::NoSuchKey(var_124) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_no_such_key(var_124)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_legal_hold_response(
    output: crate::output::GetObjectLegalHoldOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_object_legal_hold(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_lock_configuration_response(
    output: crate::output::GetObjectLockConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_get_object_lock_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_retention_response(
    output: crate::output::GetObjectRetentionOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_object_retention(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_tagging_response(
    output: crate::output::GetObjectTaggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_125) = &output.version_id {
            let formatted_126 = AsRef::<str>::as_ref(inner_125);
            if !formatted_126.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_126;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_object_tagging(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_object_torrent_response(
    output: crate::output::GetObjectTorrentOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_127) = &output.request_charged {
            let formatted_128 = AsRef::<str>::as_ref(inner_127);
            if !formatted_128.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_128;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload = aws_smithy_http_server::body::Body::wrap_stream(output.body);
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_get_public_access_block_response(
    output: crate::output::GetPublicAccessBlockOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_get_public_access_block(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_head_bucket_response(
    output: crate::output::HeadBucketOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_head_bucket(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_head_bucket_error(
    error: &crate::error::HeadBucketError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::HeadBucketError::NotFound(var_129) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_not_found(var_129)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_head_object_response(
    output: crate::output::HeadObjectOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_130) = &output.accept_ranges {
            let formatted_131 = AsRef::<str>::as_ref(inner_130);
            if !formatted_131.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_131;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "accept_ranges", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("accept-ranges", header_value);
            }
        }
        if let Some(inner_132) = &output.archive_status {
            let formatted_133 = AsRef::<str>::as_ref(inner_132);
            if !formatted_133.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_133;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "archive_status", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-archive-status", header_value);
            }
        }
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_134 = encoder.encode();
            if !formatted_134.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_134;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_135) = &output.cache_control {
            let formatted_136 = AsRef::<str>::as_ref(inner_135);
            if !formatted_136.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_136;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "cache_control", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Cache-Control", header_value);
            }
        }
        if let Some(inner_137) = &output.content_disposition {
            let formatted_138 = AsRef::<str>::as_ref(inner_137);
            if !formatted_138.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_138;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_disposition", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Disposition", header_value);
            }
        }
        if let Some(inner_139) = &output.content_encoding {
            let formatted_140 = AsRef::<str>::as_ref(inner_139);
            if !formatted_140.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_140;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_encoding", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Encoding", header_value);
            }
        }
        if let Some(inner_141) = &output.content_language {
            let formatted_142 = AsRef::<str>::as_ref(inner_141);
            if !formatted_142.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_142;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_language", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Language", header_value);
            }
        }
        if output.content_length != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.content_length);
            let formatted_143 = encoder.encode();
            if !formatted_143.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_143;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_length", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Length", header_value);
            }
        }
        if let Some(inner_144) = &output.content_type {
            let formatted_145 = AsRef::<str>::as_ref(inner_144);
            if !formatted_145.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_145;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "content_type", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Content-Type", header_value);
            }
        }
        if output.delete_marker {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.delete_marker);
            let formatted_146 = encoder.encode();
            if !formatted_146.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_146;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "delete_marker", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-delete-marker", header_value);
            }
        }
        if let Some(inner_147) = &output.e_tag {
            let formatted_148 = AsRef::<str>::as_ref(inner_147);
            if !formatted_148.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_148;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "e_tag", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("ETag", header_value);
            }
        }
        if let Some(inner_149) = &output.expiration {
            let formatted_150 = AsRef::<str>::as_ref(inner_149);
            if !formatted_150.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_150;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expiration", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-expiration", header_value);
            }
        }
        if let Some(inner_151) = &output.expires {
            let formatted_152 = inner_151.fmt(aws_smithy_types::date_time::Format::HttpDate)?;
            if !formatted_152.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_152;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expires", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("Expires", header_value);
            }
        }
        if let Some(inner_153) = &output.last_modified {
            let formatted_154 = inner_153.fmt(aws_smithy_types::date_time::Format::HttpDate)?;
            if !formatted_154.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_154;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "last_modified", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("Last-Modified", header_value);
            }
        }
        if let Some(inner_155) = &output.metadata {
            for (k, v) in inner_155 {
                use std::str::FromStr;
                let header_name =
                    http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                        .map_err(|err| {
                            aws_smithy_http_server::rejection::Serialize::from(
                                format!("{} cannot be used as a header name: {}", "metadata", err)
                                    .as_str(),
                            )
                        })?;
                use std::convert::TryFrom;
                let header_value = AsRef::<str>::as_ref(v);
                let header_value =
                    http::header::HeaderValue::try_from(header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "metadata", err)
                                .as_str(),
                        )
                    })?;
                response = response.header(header_name, header_value);
            }
        }
        if output.missing_meta != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.missing_meta);
            let formatted_156 = encoder.encode();
            if !formatted_156.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_156;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "missing_meta", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-missing-meta", header_value);
            }
        }
        if let Some(inner_157) = &output.object_lock_legal_hold_status {
            let formatted_158 = AsRef::<str>::as_ref(inner_157);
            if !formatted_158.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_158;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "object_lock_legal_hold_status", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-object-lock-legal-hold", header_value);
            }
        }
        if let Some(inner_159) = &output.object_lock_mode {
            let formatted_160 = AsRef::<str>::as_ref(inner_159);
            if !formatted_160.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_160;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "object_lock_mode", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-object-lock-mode", header_value);
            }
        }
        if let Some(inner_161) = &output.object_lock_retain_until_date {
            let formatted_162 = inner_161.fmt(aws_smithy_types::date_time::Format::DateTime)?;
            if !formatted_162.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_162;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "object_lock_retain_until_date", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-object-lock-retain-until-date", header_value);
            }
        }
        if output.parts_count != 0 {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.parts_count);
            let formatted_163 = encoder.encode();
            if !formatted_163.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_163;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "parts_count", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-mp-parts-count", header_value);
            }
        }
        if let Some(inner_164) = &output.replication_status {
            let formatted_165 = AsRef::<str>::as_ref(inner_164);
            if !formatted_165.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_165;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "replication_status", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-replication-status", header_value);
            }
        }
        if let Some(inner_166) = &output.request_charged {
            let formatted_167 = AsRef::<str>::as_ref(inner_166);
            if !formatted_167.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_167;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_168) = &output.restore {
            let formatted_169 = AsRef::<str>::as_ref(inner_168);
            if !formatted_169.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_169;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "restore", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-restore", header_value);
            }
        }
        if let Some(inner_170) = &output.sse_customer_algorithm {
            let formatted_171 = AsRef::<str>::as_ref(inner_170);
            if !formatted_171.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_171;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_172) = &output.sse_customer_key_md5 {
            let formatted_173 = AsRef::<str>::as_ref(inner_172);
            if !formatted_173.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_173;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_174) = &output.ssekms_key_id {
            let formatted_175 = AsRef::<str>::as_ref(inner_174);
            if !formatted_175.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_175;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_176) = &output.server_side_encryption {
            let formatted_177 = AsRef::<str>::as_ref(inner_176);
            if !formatted_177.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_177;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_178) = &output.storage_class {
            let formatted_179 = AsRef::<str>::as_ref(inner_178);
            if !formatted_179.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_179;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "storage_class", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-storage-class", header_value);
            }
        }
        if let Some(inner_180) = &output.version_id {
            let formatted_181 = AsRef::<str>::as_ref(inner_180);
            if !formatted_181.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_181;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        if let Some(inner_182) = &output.website_redirect_location {
            let formatted_183 = AsRef::<str>::as_ref(inner_182);
            if !formatted_183.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_183;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "website_redirect_location", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-website-redirect-location", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_head_object(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_head_object_error(
    error: &crate::error::HeadObjectError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::HeadObjectError::NotFound(var_184) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_not_found(var_184)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_bucket_analytics_configurations_response(
    output: crate::output::ListBucketAnalyticsConfigurationsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_list_bucket_analytics_configurations(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_bucket_intelligent_tiering_configurations_response(
    output: crate::output::ListBucketIntelligentTieringConfigurationsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_list_bucket_intelligent_tiering_configurations(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_bucket_inventory_configurations_response(
    output: crate::output::ListBucketInventoryConfigurationsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_list_bucket_inventory_configurations(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_bucket_metrics_configurations_response(
    output: crate::output::ListBucketMetricsConfigurationsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_list_bucket_metrics_configurations(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_buckets_response(
    output: crate::output::ListBucketsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_list_buckets(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_multipart_uploads_response(
    output: crate::output::ListMultipartUploadsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_list_multipart_uploads(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_objects_response(
    output: crate::output::ListObjectsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_list_objects(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_objects_error(
    error: &crate::error::ListObjectsError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::ListObjectsError::NoSuchBucket(var_185) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_no_such_bucket(var_185)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_objects_v2_response(
    output: crate::output::ListObjectsV2Output,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_list_objects_v2(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_objects_v2_error(
    error: &crate::error::ListObjectsV2Error,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::ListObjectsV2Error::NoSuchBucket(var_186) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_no_such_bucket(var_186)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_object_versions_response(
    output: crate::output::ListObjectVersionsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_list_object_versions(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_list_parts_response(
    output: crate::output::ListPartsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_187) = &output.abort_date {
            let formatted_188 = inner_187.fmt(aws_smithy_types::date_time::Format::HttpDate)?;
            if !formatted_188.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_188;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "abort_date", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-abort-date", header_value);
            }
        }
        if let Some(inner_189) = &output.abort_rule_id {
            let formatted_190 = AsRef::<str>::as_ref(inner_189);
            if !formatted_190.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_190;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "abort_rule_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-abort-rule-id", header_value);
            }
        }
        if let Some(inner_191) = &output.request_charged {
            let formatted_192 = AsRef::<str>::as_ref(inner_191);
            if !formatted_192.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_192;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_list_parts(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_accelerate_configuration_response(
    output: crate::output::PutBucketAccelerateConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_accelerate_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_acl_response(
    output: crate::output::PutBucketAclOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_acl(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_analytics_configuration_response(
    output: crate::output::PutBucketAnalyticsConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_analytics_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_cors_response(
    output: crate::output::PutBucketCorsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_cors(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_encryption_response(
    output: crate::output::PutBucketEncryptionOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_encryption(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_intelligent_tiering_configuration_response(
    output: crate::output::PutBucketIntelligentTieringConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_intelligent_tiering_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_inventory_configuration_response(
    output: crate::output::PutBucketInventoryConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_inventory_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_lifecycle_configuration_response(
    output: crate::output::PutBucketLifecycleConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_lifecycle_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_logging_response(
    output: crate::output::PutBucketLoggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_logging(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_metrics_configuration_response(
    output: crate::output::PutBucketMetricsConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_metrics_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_notification_configuration_response(
    output: crate::output::PutBucketNotificationConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_notification_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_ownership_controls_response(
    output: crate::output::PutBucketOwnershipControlsOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_bucket_ownership_controls(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_policy_response(
    output: crate::output::PutBucketPolicyOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_policy(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_replication_response(
    output: crate::output::PutBucketReplicationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_replication(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_request_payment_response(
    output: crate::output::PutBucketRequestPaymentOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_request_payment(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_tagging_response(
    output: crate::output::PutBucketTaggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_tagging(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_versioning_response(
    output: crate::output::PutBucketVersioningOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_versioning(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_bucket_website_response(
    output: crate::output::PutBucketWebsiteOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_bucket_website(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_response(
    output: crate::output::PutObjectOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_193 = encoder.encode();
            if !formatted_193.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_193;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_194) = &output.e_tag {
            let formatted_195 = AsRef::<str>::as_ref(inner_194);
            if !formatted_195.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_195;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "e_tag", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("ETag", header_value);
            }
        }
        if let Some(inner_196) = &output.expiration {
            let formatted_197 = AsRef::<str>::as_ref(inner_196);
            if !formatted_197.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_197;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "expiration", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-expiration", header_value);
            }
        }
        if let Some(inner_198) = &output.request_charged {
            let formatted_199 = AsRef::<str>::as_ref(inner_198);
            if !formatted_199.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_199;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_200) = &output.sse_customer_algorithm {
            let formatted_201 = AsRef::<str>::as_ref(inner_200);
            if !formatted_201.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_201;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_202) = &output.sse_customer_key_md5 {
            let formatted_203 = AsRef::<str>::as_ref(inner_202);
            if !formatted_203.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_203;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_204) = &output.ssekms_encryption_context {
            let formatted_205 = AsRef::<str>::as_ref(inner_204);
            if !formatted_205.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_205;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_encryption_context", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption-context", header_value);
            }
        }
        if let Some(inner_206) = &output.ssekms_key_id {
            let formatted_207 = AsRef::<str>::as_ref(inner_206);
            if !formatted_207.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_207;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_208) = &output.server_side_encryption {
            let formatted_209 = AsRef::<str>::as_ref(inner_208);
            if !formatted_209.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_209;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_210) = &output.version_id {
            let formatted_211 = AsRef::<str>::as_ref(inner_210);
            if !formatted_211.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_211;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_object(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_acl_response(
    output: crate::output::PutObjectAclOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_212) = &output.request_charged {
            let formatted_213 = AsRef::<str>::as_ref(inner_212);
            if !formatted_213.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_213;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_object_acl(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_acl_error(
    error: &crate::error::PutObjectAclError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::PutObjectAclError::NoSuchKey(var_214) => {
                let payload =
                    crate::operation_ser::serialize_structure_crate_error_no_such_key(var_214)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_legal_hold_response(
    output: crate::output::PutObjectLegalHoldOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_215) = &output.request_charged {
            let formatted_216 = AsRef::<str>::as_ref(inner_215);
            if !formatted_216.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_216;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_object_legal_hold(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_lock_configuration_response(
    output: crate::output::PutObjectLockConfigurationOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_217) = &output.request_charged {
            let formatted_218 = AsRef::<str>::as_ref(inner_217);
            if !formatted_218.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_218;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload = crate::operation_ser::serialize_operation_crate_operation_put_object_lock_configuration(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_retention_response(
    output: crate::output::PutObjectRetentionOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_219) = &output.request_charged {
            let formatted_220 = AsRef::<str>::as_ref(inner_219);
            if !formatted_220.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_220;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_object_retention(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_object_tagging_response(
    output: crate::output::PutObjectTaggingOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_221) = &output.version_id {
            let formatted_222 = AsRef::<str>::as_ref(inner_221);
            if !formatted_222.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_222;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "version_id", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("x-amz-version-id", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_object_tagging(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_put_public_access_block_response(
    output: crate::output::PutPublicAccessBlockOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_put_public_access_block(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_restore_object_response(
    output: crate::output::RestoreObjectOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if let Some(inner_223) = &output.request_charged {
            let formatted_224 = AsRef::<str>::as_ref(inner_223);
            if !formatted_224.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_224;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_225) = &output.restore_output_path {
            let formatted_226 = AsRef::<str>::as_ref(inner_225);
            if !formatted_226.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_226;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "restore_output_path", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-restore-output-path", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_restore_object(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_restore_object_error(
    error: &crate::error::RestoreObjectError,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        let response: axum_core::response::Response;
        match error {
            crate::error::RestoreObjectError::ObjectAlreadyInActiveTierError(var_227) => {
                let payload = crate::operation_ser::serialize_structure_crate_error_object_already_in_active_tier_error(var_227)?;
                response = http::Response::builder()
                    .status(400)
                    .body(aws_smithy_http_server::body::to_boxed(payload))?;
            }
        };
        response
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_upload_part_response(
    output: crate::output::UploadPartOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_228 = encoder.encode();
            if !formatted_228.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_228;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_229) = &output.e_tag {
            let formatted_230 = AsRef::<str>::as_ref(inner_229);
            if !formatted_230.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_230;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!("{} cannot be used as a header value: {}", "e_tag", err)
                                .as_str(),
                        )
                    })?;
                response = response.header("ETag", header_value);
            }
        }
        if let Some(inner_231) = &output.request_charged {
            let formatted_232 = AsRef::<str>::as_ref(inner_231);
            if !formatted_232.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_232;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_233) = &output.sse_customer_algorithm {
            let formatted_234 = AsRef::<str>::as_ref(inner_233);
            if !formatted_234.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_234;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_235) = &output.sse_customer_key_md5 {
            let formatted_236 = AsRef::<str>::as_ref(inner_235);
            if !formatted_236.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_236;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_237) = &output.ssekms_key_id {
            let formatted_238 = AsRef::<str>::as_ref(inner_237);
            if !formatted_238.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_238;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_239) = &output.server_side_encryption {
            let formatted_240 = AsRef::<str>::as_ref(inner_239);
            if !formatted_240.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_240;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_upload_part(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_upload_part_copy_response(
    output: crate::output::UploadPartCopyOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        if output.bucket_key_enabled {
            let mut encoder = aws_smithy_types::primitive::Encoder::from(output.bucket_key_enabled);
            let formatted_241 = encoder.encode();
            if !formatted_241.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_241;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "bucket_key_enabled", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_242) = &output.copy_source_version_id {
            let formatted_243 = AsRef::<str>::as_ref(inner_242);
            if !formatted_243.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_243;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "copy_source_version_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-copy-source-version-id", header_value);
            }
        }
        if let Some(inner_244) = &output.request_charged {
            let formatted_245 = AsRef::<str>::as_ref(inner_244);
            if !formatted_245.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_245;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "request_charged", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_246) = &output.sse_customer_algorithm {
            let formatted_247 = AsRef::<str>::as_ref(inner_246);
            if !formatted_247.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_247;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_algorithm", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_248) = &output.sse_customer_key_md5 {
            let formatted_249 = AsRef::<str>::as_ref(inner_248);
            if !formatted_249.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_249;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "sse_customer_key_md5", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_250) = &output.ssekms_key_id {
            let formatted_251 = AsRef::<str>::as_ref(inner_250);
            if !formatted_251.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_251;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "ssekms_key_id", err
                            )
                            .as_str(),
                        )
                    })?;
                response =
                    response.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_252) = &output.server_side_encryption {
            let formatted_253 = AsRef::<str>::as_ref(inner_252);
            if !formatted_253.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_253;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        aws_smithy_http_server::rejection::Serialize::from(
                            format!(
                                "{} cannot be used as a header value: {}",
                                "server_side_encryption", err
                            )
                            .as_str(),
                        )
                    })?;
                response = response.header("x-amz-server-side-encryption", header_value);
            }
        }
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_upload_part_copy(&output)?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn serialize_write_get_object_response_response(
    output: crate::output::WriteGetObjectResponseOutput,
) -> std::result::Result<
    axum_core::response::Response,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    Ok({
        #[allow(unused_mut)]
        let mut response = http::Response::builder();
        let payload =
            crate::operation_ser::serialize_operation_crate_operation_write_get_object_response(
                &output,
            )?;
        response.body(aws_smithy_http_server::body::to_boxed(payload))?
    })
}

pub fn serialize_operation_crate_operation_abort_multipart_upload(
    output: &crate::output::AbortMultipartUploadOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("AbortMultipartUploadOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_abort_multipart_upload_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_no_such_upload(
    error: &crate::error::NoSuchUpload,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_no_such_upload(error, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_complete_multipart_upload(
    output: &crate::output::CompleteMultipartUploadOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("CompleteMultipartUploadResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_complete_multipart_upload_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_copy_object(
    output: &crate::output::CopyObjectOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("CopyObjectOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_copy_object_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_object_not_in_active_tier_error(
    error: &crate::error::ObjectNotInActiveTierError,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_object_not_in_active_tier_error(
            error, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_create_bucket(
    output: &crate::output::CreateBucketOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("CreateBucketOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_create_bucket_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_bucket_already_owned_by_you(
    error: &crate::error::BucketAlreadyOwnedByYou,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_bucket_already_owned_by_you(error, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_bucket_already_exists(
    error: &crate::error::BucketAlreadyExists,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_bucket_already_exists(error, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_create_multipart_upload(
    output: &crate::output::CreateMultipartUploadOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("InitiateMultipartUploadResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_create_multipart_upload_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket(
    output: &crate::output::DeleteBucketOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_analytics_configuration(
    output: &crate::output::DeleteBucketAnalyticsConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketAnalyticsConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_analytics_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_cors(
    output: &crate::output::DeleteBucketCorsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketCorsOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_cors_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_encryption(
    output: &crate::output::DeleteBucketEncryptionOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketEncryptionOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_encryption_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_intelligent_tiering_configuration(
    output: &crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketIntelligentTieringConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_intelligent_tiering_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_inventory_configuration(
    output: &crate::output::DeleteBucketInventoryConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketInventoryConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_inventory_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_lifecycle(
    output: &crate::output::DeleteBucketLifecycleOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketLifecycleOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_lifecycle_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_metrics_configuration(
    output: &crate::output::DeleteBucketMetricsConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketMetricsConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_metrics_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_ownership_controls(
    output: &crate::output::DeleteBucketOwnershipControlsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketOwnershipControlsOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_ownership_controls_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_policy(
    output: &crate::output::DeleteBucketPolicyOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketPolicyOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_policy_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_replication(
    output: &crate::output::DeleteBucketReplicationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketReplicationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_replication_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_tagging(
    output: &crate::output::DeleteBucketTaggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketTaggingOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_tagging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_bucket_website(
    output: &crate::output::DeleteBucketWebsiteOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteBucketWebsiteOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_bucket_website_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_object(
    output: &crate::output::DeleteObjectOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteObjectOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_object_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_objects(
    output: &crate::output::DeleteObjectsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_objects_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_object_tagging(
    output: &crate::output::DeleteObjectTaggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeleteObjectTaggingOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_object_tagging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_delete_public_access_block(
    output: &crate::output::DeletePublicAccessBlockOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("DeletePublicAccessBlockOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_delete_public_access_block_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_accelerate_configuration(
    output: &crate::output::GetBucketAccelerateConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("AccelerateConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_accelerate_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_acl(
    output: &crate::output::GetBucketAclOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("AccessControlPolicy")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_acl_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_analytics_configuration(
    output: &crate::output::GetBucketAnalyticsConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketAnalyticsConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_analytics_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_cors(
    output: &crate::output::GetBucketCorsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("CORSConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_cors_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_encryption(
    output: &crate::output::GetBucketEncryptionOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketEncryptionOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_encryption_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_intelligent_tiering_configuration(
    output: &crate::output::GetBucketIntelligentTieringConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketIntelligentTieringConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_intelligent_tiering_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_inventory_configuration(
    output: &crate::output::GetBucketInventoryConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketInventoryConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_inventory_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_lifecycle_configuration(
    output: &crate::output::GetBucketLifecycleConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("LifecycleConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_lifecycle_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_location(
    output: &crate::output::GetBucketLocationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("LocationConstraint")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_location_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_logging(
    output: &crate::output::GetBucketLoggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("BucketLoggingStatus")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_logging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_metrics_configuration(
    output: &crate::output::GetBucketMetricsConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketMetricsConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_metrics_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_notification_configuration(
    output: &crate::output::GetBucketNotificationConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("NotificationConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_notification_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_ownership_controls(
    output: &crate::output::GetBucketOwnershipControlsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketOwnershipControlsOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_ownership_controls_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_policy(
    output: &crate::output::GetBucketPolicyOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketPolicyOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_policy_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_policy_status(
    output: &crate::output::GetBucketPolicyStatusOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketPolicyStatusOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_policy_status_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_replication(
    output: &crate::output::GetBucketReplicationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetBucketReplicationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_replication_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_request_payment(
    output: &crate::output::GetBucketRequestPaymentOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("RequestPaymentConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_request_payment_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_tagging(
    output: &crate::output::GetBucketTaggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Tagging")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_tagging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_versioning(
    output: &crate::output::GetBucketVersioningOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("VersioningConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_versioning_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_bucket_website(
    output: &crate::output::GetBucketWebsiteOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("WebsiteConfiguration")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_bucket_website_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_no_such_key(
    error: &crate::error::NoSuchKey,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_no_such_key(error, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_invalid_object_state(
    error: &crate::error::InvalidObjectState,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_invalid_object_state(error, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_object_acl(
    output: &crate::output::GetObjectAclOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("AccessControlPolicy")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_object_acl_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_object_legal_hold(
    output: &crate::output::GetObjectLegalHoldOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetObjectLegalHoldOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_object_legal_hold_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_object_lock_configuration(
    output: &crate::output::GetObjectLockConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetObjectLockConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_object_lock_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_object_retention(
    output: &crate::output::GetObjectRetentionOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetObjectRetentionOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_object_retention_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_object_tagging(
    output: &crate::output::GetObjectTaggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Tagging")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_object_tagging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_get_public_access_block(
    output: &crate::output::GetPublicAccessBlockOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("GetPublicAccessBlockOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_get_public_access_block_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_head_bucket(
    output: &crate::output::HeadBucketOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("HeadBucketOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_head_bucket_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_not_found(
    error: &crate::error::NotFound,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_not_found(error, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_head_object(
    output: &crate::output::HeadObjectOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("HeadObjectOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_head_object_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_bucket_analytics_configurations(
    output: &crate::output::ListBucketAnalyticsConfigurationsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListBucketAnalyticsConfigurationResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_bucket_analytics_configurations_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_bucket_intelligent_tiering_configurations(
    output: &crate::output::ListBucketIntelligentTieringConfigurationsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListBucketIntelligentTieringConfigurationsOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_bucket_intelligent_tiering_configurations_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_bucket_inventory_configurations(
    output: &crate::output::ListBucketInventoryConfigurationsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListInventoryConfigurationsResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_bucket_inventory_configurations_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_bucket_metrics_configurations(
    output: &crate::output::ListBucketMetricsConfigurationsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListMetricsConfigurationsResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_bucket_metrics_configurations_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_buckets(
    output: &crate::output::ListBucketsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListAllMyBucketsResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_buckets_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_multipart_uploads(
    output: &crate::output::ListMultipartUploadsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListMultipartUploadsResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_multipart_uploads_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_objects(
    output: &crate::output::ListObjectsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListBucketResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_objects_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_no_such_bucket(
    error: &crate::error::NoSuchBucket,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_no_such_bucket(error, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_objects_v2(
    output: &crate::output::ListObjectsV2Output,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListBucketResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_objects_v2_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_object_versions(
    output: &crate::output::ListObjectVersionsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListVersionsResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_object_versions_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_list_parts(
    output: &crate::output::ListPartsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("ListPartsResult")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_list_parts_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_accelerate_configuration(
    output: &crate::output::PutBucketAccelerateConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketAccelerateConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_accelerate_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_acl(
    output: &crate::output::PutBucketAclOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketAclOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_acl_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_analytics_configuration(
    output: &crate::output::PutBucketAnalyticsConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketAnalyticsConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_analytics_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_cors(
    output: &crate::output::PutBucketCorsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketCorsOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_cors_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_encryption(
    output: &crate::output::PutBucketEncryptionOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketEncryptionOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_encryption_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_intelligent_tiering_configuration(
    output: &crate::output::PutBucketIntelligentTieringConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketIntelligentTieringConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_intelligent_tiering_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_inventory_configuration(
    output: &crate::output::PutBucketInventoryConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketInventoryConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_inventory_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_lifecycle_configuration(
    output: &crate::output::PutBucketLifecycleConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketLifecycleConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_lifecycle_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_logging(
    output: &crate::output::PutBucketLoggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketLoggingOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_logging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_metrics_configuration(
    output: &crate::output::PutBucketMetricsConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketMetricsConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_metrics_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_notification_configuration(
    output: &crate::output::PutBucketNotificationConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketNotificationConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_notification_configuration_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_ownership_controls(
    output: &crate::output::PutBucketOwnershipControlsOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketOwnershipControlsOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_ownership_controls_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_policy(
    output: &crate::output::PutBucketPolicyOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketPolicyOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_policy_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_replication(
    output: &crate::output::PutBucketReplicationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketReplicationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_replication_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_request_payment(
    output: &crate::output::PutBucketRequestPaymentOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketRequestPaymentOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_request_payment_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_tagging(
    output: &crate::output::PutBucketTaggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketTaggingOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_tagging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_versioning(
    output: &crate::output::PutBucketVersioningOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketVersioningOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_versioning_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_bucket_website(
    output: &crate::output::PutBucketWebsiteOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutBucketWebsiteOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_bucket_website_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_object(
    output: &crate::output::PutObjectOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutObjectOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_object_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_object_acl(
    output: &crate::output::PutObjectAclOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutObjectAclOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_object_acl_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_object_legal_hold(
    output: &crate::output::PutObjectLegalHoldOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutObjectLegalHoldOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_object_legal_hold_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_object_lock_configuration(
    output: &crate::output::PutObjectLockConfigurationOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutObjectLockConfigurationOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_object_lock_configuration_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_object_retention(
    output: &crate::output::PutObjectRetentionOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutObjectRetentionOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_object_retention_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_object_tagging(
    output: &crate::output::PutObjectTaggingOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutObjectTaggingOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_object_tagging_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_put_public_access_block(
    output: &crate::output::PutPublicAccessBlockOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("PutPublicAccessBlockOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_put_public_access_block_output(
            output, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_restore_object(
    output: &crate::output::RestoreObjectOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("RestoreObjectOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_restore_object_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_structure_crate_error_object_already_in_active_tier_error(
    error: &crate::error::ObjectAlreadyInActiveTierError,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("Error")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_error_object_already_in_active_tier_error(
            error, root,
        )?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_upload_part(
    output: &crate::output::UploadPartOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("UploadPartOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_upload_part_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_upload_part_copy(
    output: &crate::output::UploadPartCopyOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("UploadPartCopyOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_upload_part_copy_output(output, root)?
    }
    Ok(out)
}

pub fn serialize_operation_crate_operation_write_get_object_response(
    output: &crate::output::WriteGetObjectResponseOutput,
) -> Result<String, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    {
        let mut writer = aws_smithy_xml::encode::XmlWriter::new(&mut out);
        #[allow(unused_mut)]
        let mut root = writer
            .start_el("WriteGetObjectResponseOutput")
            .write_ns("http://s3.amazonaws.com/doc/2006-03-01/", None);
        crate::xml_ser::serialize_structure_crate_output_write_get_object_response_output(
            output, root,
        )?
    }
    Ok(out)
}
