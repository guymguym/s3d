//! # build.rs
//!
//! This build script runs automatically by cargo
//! and generates `$OUT_DIR/s3.rs` based on `models/s3.json` smithy JSON AST
//!
//! See:
//! - https://awslabs.github.io/smithy/1.0/spec/index.html
//! - https://awslabs.github.io/smithy/1.0/spec/core/json-ast.html
//!
use serde_json::Value;
use std::{
    collections::HashMap,
    env,
    fs::File,
    io::{BufWriter, Write},
    path::Path,
};

const MODELS_DIR: &str = "models";

// smithy.api traits used in s3.json:
const _SM_PREFIX: &str = "smithy.api#";
const _SM_DOC: &str = "smithy.api#documentation";
const SM_ENUM: &str = "smithy.api#enum";
const _SM_ERROR: &str = "smithy.api#error";
const _SM_REQUIRED: &str = "smithy.api#required";
const _SM_HTTP: &str = "smithy.api#http";
const _SM_HTTP_LABEL: &str = "smithy.api#httpLabel";
const SM_HTTP_QUERY: &str = "smithy.api#httpQuery";
const SM_HTTP_HEADER: &str = "smithy.api#httpHeader";
const _SM_HTTP_PAYLOAD: &str = "smithy.api#httpPayload";
const _SM_HTTP_PREFIX_HEADERS: &str = "smithy.api#httpPrefixHeaders";
const _SM_HTTP_CHECKSUM_REQUIRED: &str = "smithy.api#httpChecksumRequired";
const _SM_XML_NS: &str = "smithy.api#xmlNamespace";
const _SM_XML_NAME: &str = "smithy.api#xmlName";
const _SM_XML_ATTR: &str = "smithy.api#xmlAttribute";
const _SM_XML_FLATTENED: &str = "smithy.api#xmlFlattened";
const _SM_SENSITIVE: &str = "smithy.api#sensitive";
const _SM_TIMESTAMP_FORMAT: &str = "smithy.api#timestampFormat";
const _SM_EVENT_PAYLOAD: &str = "smithy.api#eventPayload";
const _SM_STREAMING: &str = "smithy.api#streaming";
const _SM_PAGINATED: &str = "smithy.api#paginated";
const _SM_DEPRECATED: &str = "smithy.api#deprecated";
const _SM_TITLE: &str = "smithy.api#title";
const _SM_PATTERN: &str = "smithy.api#pattern";
const _SM_LENGTH: &str = "smithy.api#length";
const _SM_HOST_LABEL: &str = "smithy.api#hostLabel";
const _SM_ENDPOINT: &str = "smithy.api#endpoint";
const _SM_AUTH: &str = "smithy.api#auth";

const HEADER: &'static str = "\
/// This file is generated by build.rs. DO NOT EDIT.

use crate::http::*;
use hyper::{Body, StatusCode, header::HeaderValue};
";

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir);
    let models_path = Path::new(MODELS_DIR);
    let s3_out_path = out_path.join("s3.rs");
    let s3_model_path = models_path.join("s3.json");
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed={}", s3_model_path.display());
    let s3_model: Value = serde_json::from_reader(File::open(s3_model_path).unwrap()).unwrap();
    let mut s3_out = BufWriter::new(File::create(s3_out_path).unwrap());
    Smithy::new(s3_model).generate_service_code(&mut s3_out);
    s3_out.flush().unwrap();
}

pub struct Smithy {
    pub model: Value,
    pub srv: Value,
    pub operations: HashMap<String, Value>,
    pub enum_types: HashMap<String, Value>,
}
impl Smithy {
    pub fn new(model: Value) -> Self {
        let srv = model["shapes"]
            .as_object()
            .unwrap()
            .iter()
            .find(|(_k, v)| v["type"].as_str() == Some("service"))
            .unwrap()
            .1
            .clone();
        let operations = srv["operations"]
            .as_array()
            .unwrap()
            .iter()
            .map(|it| target_pair(&model, it))
            .collect();
        let enum_types = model["shapes"]
            .as_object()
            .unwrap()
            .iter()
            .filter(|(_k, v)| v["traits"][SM_ENUM].is_array())
            .map(|(k, v)| (k.unprefix().uncaps(), v.clone()))
            .collect();
        Self {
            model,
            srv,
            operations,
            enum_types,
        }
    }

    pub fn generate_service_code(&self, w: &mut dyn Write) {
        writeln!(w, "{}", HEADER).unwrap();
        self.gen_ops_enum(w);
        self.gen_ops_macro(w);
        self.gen_ops_io(w);
        self.gen_enum_types(w);
        writeln!(w, "").unwrap();
    }

    ///
    /// Generates a simple enum of operation kinds.
    ///
    /// The enum has no attached state to any of the operations.
    /// It might be interesting to consider a more complex enum if needed by the daemon,
    /// or perhaps that would instead go to it's own enum, with auto-generated-mapping to this one.
    ///
    fn gen_ops_enum(&self, w: &mut dyn Write) {
        writeln!(w, "#[derive(Debug, PartialEq, Eq, Clone, Copy)]").unwrap();
        writeln!(w, "pub enum S3Ops {{").unwrap();
        for name in self.operations.keys() {
            writeln!(w, "    {},", name).unwrap();
        }
        writeln!(w, "}}\n").unwrap();
    }

    ///
    /// Generates a macro that expands a second macro per operation
    ///
    fn gen_ops_macro(&self, w: &mut dyn Write) {
        writeln!(
            w,
            "/// This macro calls a provided $macro for each S3 operation to generate code per op."
        )
        .unwrap();
        writeln!(w, "macro_rules! generate_code_for_each_s3_op {{").unwrap();
        writeln!(w, "    ($macro:ident) => {{").unwrap();
        for name in self.operations.keys() {
            writeln!(w, "        $macro!({});", name).unwrap();
        }
        writeln!(w, "    }};").unwrap();
        writeln!(w, "}}").unwrap();
        writeln!(w, "").unwrap();
        writeln!(w, "pub(crate) use generate_code_for_each_s3_op;").unwrap();
        writeln!(w, "").unwrap();

        writeln!(w, "macro_rules! generate_match_for_each_s3_op {{").unwrap();
        writeln!(w, "    ($macro:ident, $op:expr) => {{").unwrap();
        writeln!(w, "        match ($op) {{").unwrap();
        for name in self.operations.keys() {
            writeln!(w, "            S3Ops::{0} => $macro!({0}),", name).unwrap();
        }
        writeln!(w, "        }}").unwrap();
        writeln!(w, "    }};").unwrap();
        writeln!(w, "}}").unwrap();
        writeln!(w, "").unwrap();
        writeln!(w, "pub(crate) use generate_match_for_each_s3_op;").unwrap();
        writeln!(w, "").unwrap();
    }

    ///
    /// Generates an impl of ServerOperationIO per operation.
    ///
    fn gen_ops_io(&self, w: &mut dyn Write) {
        for (name, op) in self.operations.iter() {
            let input = target_pair(&self.model, &op["input"]).1;
            let output = target_pair(&self.model, &op["output"]).1;

            assert_eq!(op["type"].as_str().unwrap_or(""), "operation");
            if !input.is_null() {
                assert_eq!(input["type"].as_str().unwrap_or(""), "structure");
            }
            if !output.is_null() {
                assert_eq!(output["type"].as_str().unwrap_or(""), "structure");
            }

            writeln!(w, "pub struct {} {{}}", name).unwrap();
            writeln!(w, "impl ServerOperationIO for {} {{", name).unwrap();
            writeln!(w, "    type Input = aws_sdk_s3::input::{}Input;", name).unwrap();
            writeln!(w, "    type Output = aws_sdk_s3::output::{}Output;", name).unwrap();
            writeln!(w, "    type Error = aws_sdk_s3::error::{}Error;", name).unwrap();
            writeln!(w, "    // const OP: super::Ops = super::Ops::{};", name).unwrap();

            writeln!(w, "    fn decode_input(req: &mut S3Request)").unwrap();
            writeln!(w, "        -> Result<Self::Input, S3Error> {{").unwrap();
            writeln!(w, "        let mut b = Self::Input::builder();").unwrap();

            if !input.is_null() {
                for (member_name, member_item) in input["members"].as_object().unwrap() {
                    // let member_target = member_item["target"].as_str().unwrap();
                    // let shape = &model["shapes"][member_target].as_object().unwrap();
                    let member_snake = member_name.snake();
                    if !member_item["traits"].is_object() {
                        continue;
                    }
                    let traits = member_item["traits"].as_object().unwrap();
                    if traits.contains_key(SM_HTTP_HEADER) {
                        writeln!(
                            w,
                            "        b = b.set_{}(req.get_header(\"{}\"));",
                            member_snake,
                            traits[SM_HTTP_HEADER].as_str().unwrap()
                        )
                        .unwrap();
                    } else if traits.contains_key(SM_HTTP_QUERY) {
                        writeln!(
                            w,
                            "        b = b.set_{}(req.get_param(\"{}\"));",
                            member_snake,
                            traits[SM_HTTP_QUERY].as_str().unwrap()
                        )
                        .unwrap();
                    } else {
                        writeln!(w, "        // decode_{}();", member_snake).unwrap();
                    }
                }
            }

            writeln!(w, "        Ok(b.build()?)").unwrap();
            writeln!(w, "    }}").unwrap();

            writeln!(w, "    fn encode_output(o: Self::Output)").unwrap();
            writeln!(w, "        -> Result<HttpResponse, S3Error> {{").unwrap();
            writeln!(w, "        let mut r = responder();").unwrap();
            writeln!(w, "        let h = r.headers_mut().unwrap();").unwrap();
            if output.is_null() {
                writeln!(w, "        Ok(r.body(Body::empty())?)").unwrap();
            } else {
                for (member_name, member_item) in output["members"].as_object().unwrap() {
                    // let member_target = member_item["target"].as_str().unwrap();
                    // let shape = &model["shapes"][member_target].as_object().unwrap();
                    let member_snake = member_name.snake();
                    if !member_item["traits"].is_object() {
                        continue;
                    }
                    let traits = member_item["traits"].as_object().unwrap();
                    if traits.contains_key(SM_HTTP_HEADER) {
                        writeln!(
                            w,
                            "        o.{}().set_header(h, \"{}\");",
                            member_snake,
                            traits[SM_HTTP_HEADER].as_str().unwrap()
                        )
                        .unwrap();
                    } else {
                        writeln!(w, "        // encode_{}();", member_snake).unwrap();
                    }
                }
                writeln!(w, "        Ok(r.body(Body::empty())?)").unwrap();
            }
            writeln!(w, "    }}").unwrap();
            writeln!(w, "}}").unwrap();
        }
        writeln!(w, "\n").unwrap();
    }

    fn gen_enum_types(&self, w: &mut dyn Write) {
        for name in self.enum_types.keys() {
            writeln!(w, "impl FromHttp for aws_sdk_s3::model::{} {{", name).unwrap();
            writeln!(w, "    fn from_http(v: &str) -> Option<Self> {{").unwrap();
            writeln!(w, "        Some(Self::from(v))").unwrap();
            writeln!(w, "    }}").unwrap();
            writeln!(w, "}}").unwrap();
            writeln!(w, "impl ToHeader for &aws_sdk_s3::model::{} {{", name).unwrap();
            writeln!(w, "    fn to_header(self) -> Option<HeaderValue> {{").unwrap();
            writeln!(w, "        self.as_str().to_header()").unwrap();
            writeln!(w, "    }}").unwrap();
            writeln!(w, "}}").unwrap();
        }
    }
}

// match type_name {
//     "service" => {}
//     "operation" => {}
//     "structure" => {
//         // gen_decode_fn_def_struct(w, &sname, &name, &shape);
//         gen_decode_fn_def(w, &sname, &format!("aws_sdk_s3::model::{}", name), None);
//     }
//     "union" => {
//         gen_decode_fn_def(w, &sname, "String", None);
//     }
//     "list" | "set" => {
//         gen_decode_fn_def(w, &sname, "Vec<String>", None);
//     }
//     "map" => {
//         gen_decode_fn_def(w, &sname, "HashMap<String,String>", None);
//     }
//     "string" => {
//         gen_decode_fn_def(w, &sname, "String", None);
//     }
//     "boolean" => {
//         gen_decode_fn_def(w, &sname, "bool", None);
//     }
//     "timestamp" => {
//         gen_decode_fn_def(w, &sname, "aws_smithy_types::date_time::DateTime", None);
//     }
//     "document" => {
//         gen_decode_fn_def(w, &sname, "String", None);
//     }
//     "blob" => {
//         gen_decode_fn_def(w, &sname, "Vec<u8>", None);
//     }
//     "integer" => {
//         gen_decode_fn_def(w, &sname, "i32", None);
//     }
//     "byte" => {
//         gen_decode_fn_def(w, &sname, "u8", None);
//     }
//     "short" => {
//         gen_decode_fn_def(w, &sname, "i16", None);
//     }
//     "long" => {
//         gen_decode_fn_def(w, &sname, "i64", None);
//     }
//     "float" => {
//         gen_decode_fn_def(w, &sname, "f32", None);
//     }
//     "double" => {
//         gen_decode_fn_def(w, &sname, "f64", None);
//     }
//     "bigInteger" => {
//         gen_decode_fn_def(w, &sname, "i64", None);
//     }
//     "bigDecimal" => {
//         gen_decode_fn_def(w, &sname, "f64", None);
//     }
//     _ => {
//         panic!("Unsupported type {}", type_name);
//     }
// }

// fn gen_decode_fn_def_struct(w: &mut dyn Write, sname: &str, name: &str, shape: &Value) {
//     let type_ref = if name.ends_with("Request") && name != "RestoreRequest" {
//         format!("{}Input", name.trim_end_matches("Request"))
//     } else {
//         format!("{}", name)
//     };
//     writeln!(w, "pub fn decode_{}() -> Option<{}> {{", sname, type_ref).unwrap();
//     for (_member_name, member_shape) in shape["members"].as_object().unwrap() {
//         let member_target = member_shape["target"].as_str().unwrap().unprefix();
//         writeln!(w, "    decode_{}();", member_target.snake()).unwrap();
//     }
//     writeln!(w, "    None").unwrap();
//     writeln!(w, "}}").unwrap();
// }

// fn gen_decode_fn_def(w: &mut dyn Write, sname: &str, return_type: &str, body: Option<&str>) {
//     write!(
//         w,
//         "
// pub fn decode_{}() -> Option<{}> {}
// ",
//         sname,
//         return_type,
//         body.unwrap_or("{ None }")
//     )
//     .unwrap();
// }

fn target_pair(model: &Value, item: &Value) -> (String, Value) {
    if item["target"].is_string() {
        let target = item["target"].as_str().unwrap();
        let name = target.unprefix().uncaps();
        let shape = model["shapes"][target].clone();
        (name, shape)
    } else {
        ("".to_string(), Value::Null)
    }
}

trait Unprefix {
    fn unprefix(&self) -> String;
}
impl Unprefix for String {
    fn unprefix(&self) -> String {
        self.as_str().unprefix()
    }
}
impl Unprefix for &str {
    fn unprefix(&self) -> String {
        self.split_once('#').unwrap().1.to_string()
    }
}

trait Uncaps {
    fn uncaps(&self) -> String;
}
impl Uncaps for String {
    fn uncaps(&self) -> String {
        self.as_str().uncaps()
    }
}
impl Uncaps for &str {
    fn uncaps(&self) -> String {
        let mut out = String::new();
        let mut upper_streak = 0;
        for c in self.chars() {
            if c.is_uppercase() || c.is_numeric() {
                if upper_streak == 0 {
                    out.push(c);
                } else {
                    out.push(c.to_lowercase().next().unwrap());
                }
                upper_streak += 1;
            } else {
                if upper_streak > 1 && out.len() > 1 {
                    let c = out.pop().unwrap();
                    out.push(c.to_uppercase().next().unwrap());
                }
                out.push(c);
                upper_streak = 0;
            }
        }
        out
    }
}

trait Snake {
    fn snake(&self) -> String;
}
impl Snake for String {
    fn snake(&self) -> String {
        self.as_str().snake()
    }
}
impl Snake for &str {
    fn snake(&self) -> String {
        let mut out = String::new();
        let mut upper_streak = 0;
        for mut c in self.chars() {
            if c.is_uppercase() || c.is_numeric() {
                if upper_streak == 0 && out.len() > 0 && out.chars().last().unwrap() != '_' {
                    out.push('_');
                }
                out.push(c.to_lowercase().next().unwrap());
                upper_streak += 1;
            } else {
                if !c.is_alphanumeric() {
                    c = '_';
                }
                if upper_streak > 1 && out.len() > 1 && c != '_' {
                    let c = out.pop().unwrap();
                    out.push('_');
                    out.push(c);
                }
                out.push(c);
                upper_streak = 0;
            }
        }
        out
    }
}
