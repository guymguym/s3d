//! # build.rs
//!
//! This build script runs automatically by cargo
//! and generates `$OUT_DIR/s3.rs` based on `models/s3.json` smithy JSON AST
//!
//! See:
//! - https://awslabs.github.io/smithy/1.0/spec/index.html
//! - https://awslabs.github.io/smithy/1.0/spec/core/json-ast.html
//!
use serde_json::Value;
use std::{
    env,
    fs::File,
    io::Write,
    path::{Path, PathBuf},
};

const MODELS_DIR: &str = "models";
const S3_PREFIX: &str = "com.amazonaws.s3#";

const _SM_PREFIX: &str = "smithy.api#";
const _SM_DOC: &str = "smithy.api#documentation";
const _SM_ENUM: &str = "smithy.api#enum";
const _SM_ERROR: &str = "smithy.api#error";
const _SM_REQUIRED: &str = "smithy.api#required";
const _SM_HTTP: &str = "smithy.api#http";
const _SM_HTTP_LABEL: &str = "smithy.api#httpLabel";
const _SM_HTTP_QUERY: &str = "smithy.api#httpQuery";
const SM_HTTP_HEADER: &str = "smithy.api#httpHeader";
const _SM_HTTP_PAYLOAD: &str = "smithy.api#httpPayload";
const _SM_HTTP_PREFIX_HEADERS: &str = "smithy.api#httpPrefixHeaders";
const _SM_HTTP_CHECKSUM_REQUIRED: &str = "smithy.api#httpChecksumRequired";
const _SM_XML_NS: &str = "smithy.api#xmlNamespace";
const _SM_XML_NAME: &str = "smithy.api#xmlName";
const _SM_XML_ATTR: &str = "smithy.api#xmlAttribute";
const _SM_XML_FLATTENED: &str = "smithy.api#xmlFlattened";

// Other smithy.api traits used in s3.json:
//    4 "smithy.api#sensitive"
//    3 "smithy.api#timestampFormat"
//    3 "smithy.api#eventPayload"
//    2 "smithy.api#streaming"
//    2 "smithy.api#paginated"
//    2 "smithy.api#deprecated"
//    1 "smithy.api#title"
//    1 "smithy.api#pattern"
//    1 "smithy.api#length"
//    1 "smithy.api#hostLabel"
//    1 "smithy.api#endpoint"
//    1 "smithy.api#auth"

const HEADER: &'static str = "\
/// This file is generated by build.rs. DO NOT EDIT.
use crate::http::*;
use std::collections::HashMap;
";

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir);
    let models_path = Path::new(MODELS_DIR);

    let s3_out_path = out_path.join("s3.rs");
    let s3_model_path = models_path.join("s3.json");

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed={}", s3_model_path.display());

    gen_smithy_srv(s3_model_path, s3_out_path, "com.amazonaws.s3#AmazonS3");
}

fn gen_smithy_srv(model_path: PathBuf, out_path: PathBuf, srv_full_name: &str) {
    let model: Value = serde_json::from_reader(File::open(model_path).unwrap()).unwrap();
    let srv = &model["shapes"][srv_full_name];
    let mut w = File::create(out_path).unwrap();
    writeln!(w, "{}", HEADER).unwrap();
    gen_ops_enum(&mut w, &model, &srv);
    gen_ops_io(&mut w, &model, &srv);
    writeln!(w, "\n").unwrap();
    w.sync_all().unwrap();
}

fn gen_ops_enum(w: &mut dyn Write, model: &Value, srv: &Value) {
    writeln!(w, "#[derive(Debug, PartialEq, Eq, Clone, Copy)]").unwrap();
    writeln!(w, "pub enum Ops {{").unwrap();
    for op in srv["operations"].as_array().unwrap() {
        let op_name = op["target"].as_str().unwrap().unprefix().uncaps();
        writeln!(w, "    {},", op_name).unwrap();
    }
    writeln!(w, "}}\n").unwrap();
}

fn gen_ops_io(w: &mut dyn Write, model: &Value, srv: &Value) {
    write!(
        w,
        "
pub mod io {{
    use super::*;
"
    )
    .unwrap();

    for op_item in srv["operations"].as_array().unwrap() {
        let op_ref = op_item["target"].as_str().unwrap();
        let op = &model["shapes"][op_ref];
        let input_target = op["input"]["target"].as_str().unwrap_or("");
        let output_target = op["output"]["target"].as_str().unwrap_or("");
        let input = &model["shapes"][input_target];
        let output = &model["shapes"][output_target];
        assert_eq!(op["type"].as_str().unwrap_or(""), "operation");
        if !input.is_null() {
            assert_eq!(input["type"].as_str().unwrap_or(""), "structure");
        }
        if !output.is_null() {
            assert_eq!(output["type"].as_str().unwrap_or(""), "structure");
        }
        let target_name = op_ref.unprefix();
        let op_snake = target_name.snake();
        let op_name = target_name.uncaps();

        write!(
            w,
            "
    pub struct {op_name} {{}}
    impl ServerOperationIO for {} {{
        type Input = aws_sdk_s3::input::{op_name}Input;
        type Output = aws_sdk_s3::output::{op_name}Output;
        type Error = aws_sdk_s3::error::{op_name}Error;
        //const OP: super::Ops = super::Ops::{op_name};
",
            op_name = op_name
        )
        .unwrap();

        write!(
            w,
            "
        fn decode_input(req: &mut S3Request) -> Result<Self::Input, S3Error> {{
            let mut b = Self::Input::builder();
"
        )
        .unwrap();

        if !input.is_null() {
            for (member_name, member_item) in input["members"].as_object().unwrap() {
                // let member_target = member_item["target"].as_str().unwrap();
                // let shape = &model["shapes"][member_target].as_object().unwrap();
                let member_snake = member_name.snake();
                if !member_item["traits"].is_object() {
                    continue;
                }
                let traits = member_item["traits"].as_object().unwrap();
                if traits.contains_key(SM_HTTP_HEADER) {
                    writeln!(
                        w,
                        "            b = b.set_{}(req.get_header_parse(\"{}\"));",
                        member_snake,
                        traits[SM_HTTP_HEADER].as_str().unwrap()
                    )
                    .unwrap();
                } else {
                    writeln!(w, "            // decode_{}();", member_snake).unwrap();
                }
            }
        }

        writeln!(w, "            Ok(b.build()?)").unwrap();
        writeln!(w, "        }}").unwrap();

        writeln!(
            w,
            "        fn encode_output(o: Self::Output) -> Result<HttpRequest, S3Error> {{"
        )
        .unwrap();

        if !output.is_null() {
            for (_member_name, member_item) in output["members"].as_object().unwrap() {
                let member_target = member_item["target"].as_str().unwrap().unprefix();
                writeln!(w, "            // encode_{}();", member_target.snake()).unwrap();
            }
        }

        writeln!(
            w,
            "            Err(S3Error::bad_request(\"not implemented\"))"
        )
        .unwrap();
        writeln!(w, "        }}").unwrap();
        writeln!(w, "    }}").unwrap();
    }
    writeln!(w, "}}").unwrap();
    writeln!(w, "\n").unwrap();

    /*
    for (key, shape) in model["shapes"].as_object().unwrap() {
        let name = key.unprefix();
        let sname = name.snake();
        let name = name.uncaps();
        let type_name = shape["type"].as_str().unwrap();
        match type_name {
            "service" => {}
            "operation" => {}
            "structure" => {
                gen_decode_fn_def_struct(w, &sname, &name, &shape);
            }
            "union" => {
                gen_decode_fn_def(w, &sname, "String", None);
            }
            "list" | "set" => {
                gen_decode_fn_def(w, &sname, "Vec<String>", None);
            }
            "map" => {
                gen_decode_fn_def(w, &sname, "HashMap<String,String>", None);
            }
            "string" => {
                gen_decode_fn_def(w, &sname, "String", None);
            }
            "boolean" => {
                gen_decode_fn_def(w, &sname, "bool", None);
            }
            "timestamp" => {
                gen_decode_fn_def(w, &sname, "aws_smithy_types::date_time::DateTime", None);
            }
            "document" => {
                gen_decode_fn_def(w, &sname, "String", None);
            }
            "blob" => {
                gen_decode_fn_def(w, &sname, "Vec<u8>", None);
            }
            "integer" => {
                gen_decode_fn_def(w, &sname, "i32", None);
            }
            "byte" => {
                gen_decode_fn_def(w, &sname, "u8", None);
            }
            "short" => {
                gen_decode_fn_def(w, &sname, "i16", None);
            }
            "long" => {
                gen_decode_fn_def(w, &sname, "i64", None);
            }
            "float" => {
                gen_decode_fn_def(w, &sname, "f32", None);
            }
            "double" => {
                gen_decode_fn_def(w, &sname, "f64", None);
            }
            "bigInteger" => {
                gen_decode_fn_def(w, &sname, "i64", None);
            }
            "bigDecimal" => {
                gen_decode_fn_def(w, &sname, "f64", None);
            }
            _ => {
                panic!("Unsupported type {}", type_name);
            }
        }
    }
    */
}

fn gen_decode_fn_def_struct(w: &mut dyn Write, sname: &str, name: &str, shape: &Value) {
    let type_ref = if name.ends_with("Request") && name != "RestoreRequest" {
        format!("{}Input", name.trim_end_matches("Request"))
    } else {
        format!("{}", name)
    };
    writeln!(w, "pub fn decode_{}() -> Option<{}> {{", sname, type_ref).unwrap();
    for (_member_name, member_shape) in shape["members"].as_object().unwrap() {
        let member_target = member_shape["target"].as_str().unwrap().unprefix();
        writeln!(w, "    decode_{}();", member_target.snake()).unwrap();
    }
    writeln!(w, "    None").unwrap();
    writeln!(w, "}}").unwrap();
}

fn gen_decode_fn_def(w: &mut dyn Write, sname: &str, return_type: &str, body: Option<&str>) {
    writeln!(
        w,
        "pub fn decode_{}() -> Option<{}> {}",
        sname,
        return_type,
        body.unwrap_or("{ None }")
    )
    .unwrap();
}

trait Unprefix {
    fn unprefix(&self) -> String;
}
impl Unprefix for String {
    fn unprefix(&self) -> String {
        self.as_str().unprefix()
    }
}
impl Unprefix for &str {
    fn unprefix(&self) -> String {
        self.split_once('#').unwrap().1.to_string()
    }
}

trait Uncaps {
    fn uncaps(&self) -> String;
}
impl Uncaps for String {
    fn uncaps(&self) -> String {
        self.as_str().uncaps()
    }
}
impl Uncaps for &str {
    fn uncaps(&self) -> String {
        let mut out = String::new();
        let mut upper_streak = 0;
        for c in self.chars() {
            if c.is_uppercase() || c.is_numeric() {
                if upper_streak == 0 {
                    out.push(c);
                } else {
                    out.push(c.to_lowercase().next().unwrap());
                }
                upper_streak += 1;
            } else {
                if upper_streak > 1 && out.len() > 1 {
                    let c = out.pop().unwrap();
                    out.push(c.to_uppercase().next().unwrap());
                }
                out.push(c);
                upper_streak = 0;
            }
        }
        out
    }
}

trait Snake {
    fn snake(&self) -> String;
}
impl Snake for String {
    fn snake(&self) -> String {
        self.as_str().snake()
    }
}
impl Snake for &str {
    fn snake(&self) -> String {
        let mut out = String::new();
        let mut upper_streak = 0;
        for mut c in self.chars() {
            if c.is_uppercase() || c.is_numeric() {
                if upper_streak == 0 && out.len() > 0 && out.chars().last().unwrap() != '_' {
                    out.push('_');
                }
                out.push(c.to_lowercase().next().unwrap());
                upper_streak += 1;
            } else {
                if !c.is_alphanumeric() {
                    c = '_';
                }
                if upper_streak > 1 && out.len() > 1 && c != '_' {
                    let c = out.pop().unwrap();
                    out.push('_');
                    out.push(c);
                }
                out.push(c);
                upper_streak = 0;
            }
        }
        out
    }
}
